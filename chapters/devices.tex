\chapter{Devices}
\section{Overview}

In Calimero KNX devices were represented through the \lstinline!Datapoint! class. Instances of this class could be used to send and receive messages by passing it as a parameter to a \lstinline!ProcessCommunicator!.

In Scalimero a more decentralized approach was chosen. Devices were introduced.

\paragraph{Devices have the following members(constructor parameter):}
\begin{itemize}
  \item \textbf{A KNX address} - Name: destAddr

    Can be passed as a String or GroupAddress object to the constructor of Device.
  \item \textbf{DPType} - Name: dpt

    \lstinline!DPType! is a wrapper class for \lstinline!DPT!, which means a instance of DPType or DPT can be passed as constructor parameter.
  \item \textbf{Name}[optional] - Name: name

    The name is a String an will be given to the DataPoint instance encapsulated in the Device class.
  \item \textbf{Network}[optional] - Name: net

    If this parameter is not given, the value of Network.default, which contains a reference to last created Network instance, will be taken.
\end{itemize}

\paragraph{Device traits:}
\begin{itemize}
  \item \textbf{TDevice} - Every device inherits this trait.
  \item \textbf{TCommandDevice} - Every device with the send method inherits this trait.
  \item \textbf{TStateDevice} - Every device with the read method inherits this trait.
\end{itemize}

The \lstinline!Device! base class is an Actor, which means it can send and receive messages. Because of this ability it is possible to send to the device actor \lstinline!ProcessEvent!s or \lstinline!WriteEvent!s to trigger subscribed events.

\paragraph{Subclasses of Device:}
\begin{itemize}
  \item \textbf{CommandDevice}

  This class hasn't got any state, which means it can only be used for sending messages.

    \textbf{send}(d: DataPointValue)

        \lstinline!DataPointValue! is a wrapper class for the primitive types specified through the \lstinline!DPType!. It's possible to pass a instance of \lstinline!DataPointValue! or primitive type value.
  \item \textbf{StateDevice}

  This class has the ability to send and read messages. Even though the name of the class is \lstinline!StateDevice!, no state is stored in this class. It has got two methods to read values from the KNX Network:
    \begin{itemize}
        \item \textbf{read}: PrimitveType

            Returns a value with the primitive type chosen through the \lstinline!DPType!. If it's not possible to get a message, an Exception is thrown.
        \item \textbf{readOption}: Option[PrimitiveType]

            Returns a value with the primitive type chosen through the \lstinline!DPType! encapsulated in an Option.
    \end{itemize}
\end{itemize}

\section{Device in the REPL}
It is advised to use the base Device classes only for the purpose of testing or quick scripting. In most cases it is more rewarding to create a specialzied Device class and let it inherit from \lstinline!StateDevice! or \lstinline!CommandDevice!. How this can be done exactly will be explained in the next chapter.

To use it,
\begin{lstlisting}
import tuwien.auto.scalimero
import device._
import device.dtype._
import connection._
\end{lstlisting}
Then create a network and open it. Now the creation of the devices can begin.
\begin{lstlisting}
val d1 = Device("1/1/1", Boolean.SWITCH)
\end{lstlisting}
To shorten the qualification of the \lstinline!DPType! just
\begin{lstlisting}
import device.dtype.Boolean._
\end{lstlisting}
 Now all Boolean \lstinline!DPType!s are in scope an it is possible to write
\begin{lstlisting}
val d2 = Device("1/1/0", SWITCH)
\end{lstlisting}
By writing the above code the \lstinline!apply! method of the companion object Device is called and instantiates a \lstinline!StateDevice! with the given parameters.

To send messages
\begin{lstlisting}
d1 send true
\end{lstlisting}
or
\begin{lstlisting}
d2 send on
\end{lstlisting}
To read messages
\begin{lstlisting}
try{
    if(d1 read)
        println("Lamp was turned on")
    else
        println("Lamp was turned off")
}catch {
    case e => println("No value was received, because of an Exception")
\end{lstlisting}
or
\begin{lstlisting}
d1 readOption match {
    case Some(value) =>
        if(value)
            println("Lamp was turned on")
        else
            println("Lamp was turned off")
    case _ => println("No value was received, because of an Exception")
}
\end{lstlisting}
The Device base classes can only subscribe \lstinline!WriteCallback!s.
\section{SimpleDevice}

The class \lstinline!SimpleDevice! was created because of the need for an quick to write abstract with less overhead. This is accomplished by removing the Actor functionality. This class has the same read and send methods like \lstinline!StateDevice! and some additional low level sending methods:

\begin{itemize}
  \item \textbf{readRequest} - sends a read request
  \item \textbf{write}(value: PrimitiveType) - sends a value of primitve type
  \item \textbf{write}(value: Array[Byte]) - sends a value of type byte array
  \item \textbf{write}(value: String) - sends a value of type String(the format depends on \lstinline!DPT!)
\end{itemize}
\section{Grouping of Devices}

Grouping of Devices can be done on different levels:

\begin{itemize}
  \item \textbf{low level} - through \lstinline!WriteCallback!s
  \item \textbf{mid level} - through events
  \item \textbf{high level} - through:
    \begin{itemize}
        \item \textbf{GroupDevice}
        
        \lstinline!GroupDevice! inherits from \lstinline!HashSet! and because of that it can be filled with Devices. With the \lstinline!send! method a message can be sent to all Devices in the GroupDevice. The \lstinline!setMaster! method enables you to set a master device. When the state of master device changes a message, containing the new state, is sent to all devices in the GroupDevice. Through the \lstinline!addProxyFunction! method it is possible set a function, which will be evaluated, before the new received state will be forwarded to the other devices. The Result of this function will then be sent instead of original received value.
        

\begin{lstlisting}
val gd = GroupDevice(d1, d2)

//all lights on
gd send on
//or
gd map {_ send on}

gd setMaster d1

//d2 will also be turned off automatically
d1 send off
\end{lstlisting}
        \item \textbf{MultipleAddressDevice}

        This class functions as an abstraction for a devices with a separate reading and writing address.
\begin{lstlisting}
val mad1 = new MultipleAddressDevice(d1, d2)
//or
val mad2 = new MultipleAddressDevice("1/1/1", "1/1/0", Switch)
\end{lstlisting}
    \end{itemize}
\end{itemize}
