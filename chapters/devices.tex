\chapter{Devices}
\section{Overview}

In Calimero KNX devices were represented through the \lstinline!Datapoint! class. Instances of this class could be used to send and receive messages by passing it as a parameter to a \lstinline!ProcessCommunicator!.

In Scalimero a more decentralized approach was chosen. Devices were introduced.

\paragraph{Devices have the following members (constructor parameters):}
\begin{itemize}
  \item \textbf{A KNX address} - Name: destAddr

    Can be passed as a \lstinline!String! or \lstinline!GroupAddress! object to the constructor of \lstinline!Device!.
  \item \textbf{DPType} - Name: dpt

    \lstinline!DPType! is a wrapper class for \lstinline!DPT!, which means a instance of \lstinline!DPType! or \lstinline!DPT! can be passed as a constructor parameter.
  \item \textbf{Name}[optional] - Name: name

    The name is a \lstinline!String! an will be given to the \lstinline!Datapoint! instance encapsulated in the \lstinline!Device! class.
  \item \textbf{Network}[optional] - Name: net

    If this parameter is not given, the value of \lstinline!Network.default!, which contains a reference to last created \lstinline!Network! instance, will be used.
\end{itemize}

\paragraph{Device traits:}
\begin{itemize}
  \item \textbf{TDevice} - Every device inherits this trait.
  \item \textbf{TCommandDevice} - Every device with the \lstinline!send! method inherits this trait.
  \item \textbf{TStateDevice} - Every device with the \lstinline!read! method inherits this trait.
\end{itemize}

The \lstinline!Device! base class is an \lstinline!Actor!, which means it can send and receive messages. Because of this ability it is possible to send \lstinline!ProcessEvent!s or \lstinline!WriteEvent!s to the device actor to trigger subscribed events.

\paragraph{Subclasses of Device:}
\begin{itemize}
  \item \textbf{CommandDevice}

  Devices of this class have no state, which means they can only be used for sending messages.

    \textbf{send}(d: DataPointValue)

        \lstinline!DataPointValue! subclasses are wrapper classes for primitive types. They are specified in the \lstinline!tuwien.auto.scalimero.device.dtype! package. It is possible to pass an instance of \lstinline!DataPointValue! or a primitive type value.
  \item \textbf{StateDevice}

  This class has the ability to send and read messages. Even though the name of the class is \lstinline!StateDevice!, no state is stored in the objects. It has got two methods to read values from the KNX Network:
    \begin{itemize}
        \item \textbf{read}: PrimitveType

            Returns a value with the primitive type chosen through the \lstinline!DPType!. If network communication fails, an Exception is thrown.
        \item \textbf{readOption}: Option[PrimitiveType]

            Returns a value with the primitive type chosen through the \lstinline!DPType! encapsulated in an Option.
    \end{itemize}
\end{itemize}

\section{Device in the REPL}
It is advised to use the base Device classes only for the purpose of testing or quick scripting. In most cases it is more rewarding to create a specialzied Device class and let it inherit from \lstinline!StateDevice! or \lstinline!CommandDevice!. How this can be done exactly will be explained in the next chapter.

To use it,
\begin{lstlisting}
import tuwien.auto.scalimero._
import device._
import device.dtype._
import connection._
\end{lstlisting}
Then create a network and open it. Now the creation of the devices can begin.
\begin{lstlisting}
val d1 = Device("1/1/1", Boolean.SWITCH)
\end{lstlisting}
To shorten the qualification of the \lstinline!DPType! just
\begin{lstlisting}
import device.dtype.Boolean._
\end{lstlisting}
 Now all Boolean \lstinline!DPType!s are in scope and it is possible to write
\begin{lstlisting}
val d2 = Device("1/1/0", SWITCH)
\end{lstlisting}
By writing the above code the \lstinline!apply! method of the companion object \lstinline!Device! is called and instantiates a \lstinline!StateDevice! with the given parameters.

To send messages
\begin{lstlisting}
d1 send true
\end{lstlisting}
or
\begin{lstlisting}
d2 send on
\end{lstlisting}
To read messages
\begin{lstlisting}
try{
    if(d1 read)
        println("Lamp was turned on")
    else
        println("Lamp was turned off")
} catch {
    case e => println("No value was received, because an error occured") }
\end{lstlisting}
or
\begin{lstlisting}
d1 readOption match {
    case Some(value) =>
        if(value)
            println("Lamp was turned on")
        else
            println("Lamp was turned off")
    case _ => println("No value was received, because an error occured")
}
\end{lstlisting}
The \lstinline!Device! base classes can only subscribe to \lstinline!WriteCallback!s.
\section{SimpleDevice}

The class \lstinline!SimpleDevice! was created because of the need for a quick to write abstraction with little overhead. This is accomplished by removing the Actor functionality. This class has the same \lstinline!read! and \lstinline!send! methods as \lstinline!StateDevice! and some additional low level sending methods:

\begin{itemize}
  \item \textbf{readRequest} - sends a read request
  \item \textbf{write}\lstinline!(value: PrimitiveType)! - writes a value to the KNX device
  \item \textbf{write}\lstinline!(value: Array[Byte])! - writes a value to the KNX device
  \item \textbf{write}\lstinline!(value: String)! - writes a value to the KNX device (string format depends on \lstinline!DPT!)
\end{itemize}
\clearpage
\section{Grouping of Devices}

Grouping of Devices can be done on different levels:

\begin{itemize}
  \item \textbf{low level} - through \lstinline!WriteCallback!s
  \item \textbf{mid level} - through events
  \item \textbf{high level} - through:
    \begin{itemize}
        \item \textbf{GroupDevice}
        
        \lstinline!GroupDevice! inherits from \lstinline!HashSet! and because of that it can be filled with \lstinline!Device!s. With the \lstinline!send! method a message can be sent to all \lstinline!Device!s in the \lstinline!GroupDevice!. The \lstinline!setMaster! method enables you to set a master device. When the state of the master device changes, all \lstinline!Device!s in the \lstinline!GroupDevice! are set to the same state. Through the \lstinline!addProxyFunction! method it is possible set a function which will be evaluated before the new received state is forwarded to the other devices. The result of this function will then be sent instead of the original received value.
        

\begin{lstlisting}
val gd = GroupDevice(d1, d2)

//all lights on
gd send on
//or
gd map {_ send on}

gd setMaster d1

//d2 will also be turned off automatically
d1 send off
\end{lstlisting}
        \item \textbf{MultipleAddressDevice}

        This class is an abstraction for devices with a separate reading and writing address.
\begin{lstlisting}
val mad1 = new MultipleAddressDevice(d1, d2)
//or
val mad2 = new MultipleAddressDevice("1/1/1", "1/1/0", Switch)
\end{lstlisting}
    \end{itemize}
\end{itemize}
