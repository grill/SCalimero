\chapter{Devices}
\section{Overview}

In Calimero KNX devices were represented through the \lstinline!Datapoint! class. Instances of this class could be used to send and receive messages by passing it as a parameter to a \lstinline!ProcessCommunicator!.

In Scalimero a more decentralized approach was chosen. Devices were introduced.

\paragraph{Devices have the following members(constructor parameter):}
\begin{itemize}
  \item \textbf{A KNX address} - Name: destAddr

    Can be passed as a String or GroupAddress object to the constructor of Device.
  \item \textbf{DPType} - Name: dpt

    \lstinline{DPType} is a wrapper class for \lstinline{DPT}, which means a instance of DPType or DPT can be passed as constructor parameter.
  \item \textbf{Name}[optional] - Name: name

    The name is a String an will be given to the DataPoint instance encapsulated in the Device class.
  \item \textbf{Network}[optional] - Name: net

    If this parameter is not given, the value of Network.default, which contains a reference to last created Network instance, will be taken.
\end{itemize}

\paragraph{Device traits:}
\begin{itemize}
  \item \textbf{TDevice} - Every device inherits this trait.
  \item \textbf{TCommandDevice} - Every device with the send method inherits this trait.
  \item \textbf{TStateDevice} - Every device with the read method inherits this trait.
\end{itemize}

The \lstinline{Device} base class is an Actor, which means it can send and receive messages. Because of this ability it is possible to send to the device actor \lstlisting!ProcessEvent!s or \lstlisting!WriteEvent!s to trigger subscribed events.

\paragraph{Subclasses of Device:}
\begin{itemize}
  \item \textbf{CommandDevice}

  This class hasn't got any state, which means it can only be used for sending messages.

    \textbf{send}(d: DataPointValue)

        \lstlinsting!DataPointValue! is a wrapper class for the primitive types specified through the \lstlisting!DPType!. It's possible to pass a instance of \lstlisting!DataPointValue! or primitive type value.
  \item \textbf{StateDevice}

  This class has the ability to send and read messages. Even though the name of the class is \lstlisting!StateDevice!, no state is stored in this class. It has got two methods to read values from the KNX Network:
    \begin{itemize}
        \item \textbf{read}: PrimitveType

            Returns a value with the primitive type chosen through the \lstlisting!DPType!. If it's not possible to get a message, an Exception is thrown.
        \item \textbf{readOption}: Option[PrimitiveType]

            Returns a value with the primitive type chosen through the \lstlisting!DPType! encapsulated in an Option.
    \end{itemize}
\end{itemize}

\section{Device in the REPL}
It is advised to use the base Device classes only for the purpose of testing or quick scripting. In most cases it is more rewarding to create a specialzied Device class and let it inherit from \lstlisting!StateDevice! or \lstlisting!CommandDevice!. How this can be done exactly will be explained in the next chapter.

To use it, 
\begin{lstlisting}
import tuwien.auto.scalimero
import device._
import device.dtype._
import connection._
\end{lstlisting}
Then create a network and open it. Now the creation of the devices can begin.
\begin{lstlisting}
val d1 = Device("1/1/1", Boolean.SWITCH)
\end{lstlisting}
To shorten the qualification of the \lstlisting!DPType! just
\begin{lstlisting}
import device.dtype.Boolean._
\end{lstlisting}
 Now all Boolean \lstlisting!DPType!s are in scope an it is possible to write
\begin{lstlisting}
val d2 = Device("1/1/0", SWITCH)
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}
\section{GroupDevice}

\section{SimpleDevice}