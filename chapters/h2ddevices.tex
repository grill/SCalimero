\chapter{How to write specialized devices}
This chapter is about learning how to write specialized Devices(Lamp, Dimmer, etc.) using the \lstinline!Lamp! class as an example.

At first some imports have to be written:
\begin{lstlisting}
import tuwien.auto.scalimero.device._
import tuwien.auto.scalimero.device.dtype._
import tuwien.auto.scalimero.device.dtype.Boolean._
import tuwien.auto.scalimero.device.dtype.translatortype._
import tuwien.auto.calimero.GroupAddress
\end{lstlisting}
For the next step it is advised to name the new class like an assailable object. In this case this going to be Lamp. Then it's time to decide if Lamp should inherit from \lstinline!StateDevice! or \lstinline!CommandDevice!.
\begin{lstlisting}
class Lamp(address: GroupAddress) extends StateDevice(address, SWITCH)
//or
class Lamp(address: GroupAddress) extends CommandDevice(address, SWITCH)
\end{lstlisting}
After that it's nice some times to write some alias to make the use of the new class more readable.
\begin{lstlisting}
  def turn(value: BooleanValue) = send(value)
\end{lstlisting}
 Thanks to the above statement it's possible to write\lstinline!lamp1 turn on!.
 
 Then it's advised to write some events for the new device:
\begin{lstlisting}
  override val events : Map[Any, Boolean => Boolean] = Map (
    on ->   {(b: Boolean) => b},
    off ->  {(b: Boolean) => !b}
  )
\end{lstlisting}
Because \lstinline!events! was overriden and two events were added, the example below is possible:
\begin{lstlisting}
//define our lamps
val lA = Lamp("1/1/0")
val lB = Lamp("1/1/1")

//subscribe to lamp A's on event, i.e. lB gets turned on whenever lA is turned on
lA.eventSubscribe(on){
  lB turn on
}
\end{lstlisting}

The last part of writing a specialized device is rather easy. \begin{lstlisting}
object Lamp extends TypeOfDevice {
  def apply(address : GroupAddress) = new Lamp(address)
}
\end{lstlisting}